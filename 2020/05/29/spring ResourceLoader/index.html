<!DOCTYPE html>
<html lang="en">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="spring ResourceLoader"/>








  <link rel="alternate" href="/default" title="青青草原">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="http://yoursite.com/2020/05/29/spring ResourceLoader/"/>


<meta name="description" content="ResourceLoader是对资源加载的定义，为spring资源加载统一的抽象，具体的资源加载由ResourceLoader的实现类来完成，ResourceLoader主要应用于根据给定的资源文件地址，返回对应的 Resource 。 ResourceLoader提供的方法： 123456789101112131415161718192021public interface ResourceLo">
<meta property="og:type" content="article">
<meta property="og:title" content="spring ResourceLoader">
<meta property="og:url" content="http://yoursite.com/2020/05/29/spring%20ResourceLoader/index.html">
<meta property="og:site_name" content="青青草原">
<meta property="og:description" content="ResourceLoader是对资源加载的定义，为spring资源加载统一的抽象，具体的资源加载由ResourceLoader的实现类来完成，ResourceLoader主要应用于根据给定的资源文件地址，返回对应的 Resource 。 ResourceLoader提供的方法： 123456789101112131415161718192021public interface ResourceLo">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s1.ax1x.com/2020/05/29/tnT8N8.png">
<meta property="article:published_time" content="2020-05-29T07:41:43.424Z">
<meta property="article:modified_time" content="2020-06-01T09:12:03.411Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s1.ax1x.com/2020/05/29/tnT8N8.png">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> spring ResourceLoader - 青青草原 </title>
  <meta name="generator" content="Hexo 4.2.1"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">青青草原</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          spring ResourceLoader
        
      </h1>

      <time class="post-time">
          May 29 2020
      </time>
    </header>



    
            <div class="post-content">
            <p>ResourceLoader是对资源加载的定义，为spring资源加载统一的抽象，具体的资源加载由ResourceLoader的实现类来完成，ResourceLoader主要应用于根据给定的资源文件地址，返回对应的 Resource 。</p>
<p>ResourceLoader提供的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourceLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * URL前缀：默认为classpath</span></span><br><span class="line"><span class="comment">	 * Pseudo URL prefix for loading from the class path: "classpath:".</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	String CLASSPATH_URL_PREFIX = ResourceUtils.CLASSPATH_URL_PREFIX;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 返回指定资源路径的资源</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Resource <span class="title">getResource</span><span class="params">(String location)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取当前ResourceLoader使用的ClassLoader</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function">ClassLoader <span class="title">getClassLoader</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.getResource(String location)：使用指定的资源路径返回资源(Resource实例)，该方法支持以下三种模式的资源加载：</p>
<ul>
<li>URL位置资源，如 “file:D:/test.txt” 。</li>
<li>ClassPath位置资源，如 “classpath:spring.xml”。</li>
<li>相对路径资源，如 “WEB-INF/test.txt” 。</li>
<li>此时返回的Resource 实例，根据实现不同而不同。</li>
</ul>
<p>2.getClassLoader() 方法，返回 ClassLoader 实例，对于想要获取 ResourceLoader 使用的 ClassLoader 用户来说，可以直接调用该方法来获取。在Resource的实现中ClassPathResource 这个类是可以根据指定的 ClassLoader 来加载资源的。</p>
<p>该方法的主要实现是在其子类 DefaultResourceLoader 中实现。</p>
<p>作为 Spring 统一的资源加载器，它提供了统一的抽象，具体的实现则由相应的子类来负责实现，其类的类结构图如下：<br><img src="https://s1.ax1x.com/2020/05/29/tnT8N8.png" alt="image"></p>
<p>1.DefaultResourceLoader</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">它是ResourceLoader的默认实现，与AbstractResource相似。</span><br></pre></td></tr></table></figure>
<p>DefaultResourceLoader的构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个新的DefaultResourceLoader</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultResourceLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用ClassLoader创建一个新的DefaultResourceLoader</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultResourceLoader</span><span class="params">(@Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.classLoader = classLoader;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定ClassLoader来加载类路径资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClassLoader</span><span class="params">(@Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.classLoader = classLoader;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回ClassLoader以加载类路径资源。如果没有则获取默认的ClassLoader</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">this</span>.classLoader != <span class="keyword">null</span> ? <span class="keyword">this</span>.classLoader : ClassUtils.getDefaultClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>getResource()</strong><br>方法根据资源路径返回相应的Resource,而DefaultResourceLoader 对该方法提供了核心实现（它的子类都没有提供覆盖该方法，所以ResourceLoader 的资源加载策略就封装在DefaultResourceLoader中)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Resource <span class="title">getResource</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">		Assert.notNull(location, <span class="string">"Location must not be null"</span>);</span><br><span class="line">		<span class="comment">//通过ProtocolResolver加载资源  ProtocolResolver是用户自定义资源加载策略</span></span><br><span class="line">		<span class="keyword">for</span> (ProtocolResolver protocolResolver : getProtocolResolvers()) &#123;</span><br><span class="line">			Resource resource = protocolResolver.resolve(location, <span class="keyword">this</span>);</span><br><span class="line">			<span class="keyword">if</span> (resource != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> resource;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果location是以'/'开头，返回 ClassPathContextResource 类型的资源</span></span><br><span class="line">		<span class="keyword">if</span> (location.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> getResourceByPath(location);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果location以classpath开头，返回 ClassPathResource 类型的资源</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (location.startsWith(CLASSPATH_URL_PREFIX)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// Try to parse the location as a URL...</span></span><br><span class="line">				<span class="comment">//构造URL，尝试通过它进行资源定位，如果没有抛出MalformedURLException异常，</span></span><br><span class="line">				<span class="comment">// 则判断是否是FileUrl，如果是构造FileUrlResource,否则构造UrlResource</span></span><br><span class="line">				URL url = <span class="keyword">new</span> URL(location);</span><br><span class="line">				<span class="keyword">return</span> (ResourceUtils.isFileURL(url) ? <span class="keyword">new</span> FileUrlResource(url) : <span class="keyword">new</span> UrlResource(url));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (MalformedURLException ex) &#123;</span><br><span class="line">				<span class="comment">//返回 ClassPathContextResource 类型的资源</span></span><br><span class="line">				<span class="comment">// No URL -&gt; resolve as resource path.</span></span><br><span class="line">				<span class="keyword">return</span> getResourceByPath(location);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>通过ProtocolResolver加载资源，存在则返回Resource</li>
<li>如果location是以 <strong>‘/‘</strong> 开头，就返回CLassPathContextResource类型的资源</li>
<li>如果location是以 <strong>‘classpath’</strong>  开头，就返回ClassPathResource类型的资源</li>
<li>首先构造url,尝试通过它进行资源定位，如果没有抛出 <strong>MalformedURLException</strong> 异常，则判断是否是FileUrl,如果是就构造FileUrlResource，否则构造UrlResource</li>
<li>如果抛出 <strong>MalformedURLException</strong> 异常，返回ClassPathContextResource类型的资源</li>
</ol>
<ol start="2">
<li>ProtocolResolver </li>
</ol>
<p>在getResource中 第一步先从ProtocolResolver加载资源，那ProtocolResolver到底是什么呢？</p>
<p>在Resource中，如果用户想要自定义一个Resource，那只需要继承AbstractResource就可以了。在ResourceLoader中，也有一个默认实现 <strong>DefaultResourceLoader</strong>，如果按照Resource的做法，我们只需要继承 <strong>DefaultResourceLoader</strong> 就可以了，但有了ProtocolResolver，我们不需要直接继承 <strong>DefaultResourceLoader</strong>，改为实现 ProtocolResolver 接口也可以实现自定义的 ResourceLoader。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProtocolResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 根据给定的ResourceLoader解析location 如果成功，则返回相应的Resource</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function">Resource <span class="title">resolve</span><span class="params">(String location, ResourceLoader resourceLoader)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ProtocolResolver接口没有实现类，它需要用户自定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 向该ResourceLoader注册给定的解析器</span></span><br><span class="line"><span class="comment">	 * Register the given resolver with this resource loader, allowing for</span></span><br><span class="line"><span class="comment">	 * additional protocols to be handled.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Any such resolver will be invoked ahead of this loader's standard</span></span><br><span class="line"><span class="comment">	 * resolution rules. It may therefore also override any default rules.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 4.3</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getProtocolResolvers()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addProtocolResolver</span><span class="params">(ProtocolResolver resolver)</span> </span>&#123;</span><br><span class="line">		Assert.notNull(resolver, <span class="string">"ProtocolResolver must not be null"</span>);</span><br><span class="line">		<span class="keyword">this</span>.protocolResolvers.add(resolver);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>自定义的ProtocolResolver通过DefaultResourceLoader中的addProtocolResolver()方法进行注册。</p>
<p>3.FileSystemResourceLoader</p>
<p>FileSystemResourceLoader继承了DefaultResourceLoader，并重写了getResourceByPath()方法，使之从文件系统加载资源并以 FileSystemResource 类型返回，这样我们就可以得到想要的资源类型。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Resource <span class="title">getResourceByPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//如果path开头存在'/'，则截取</span></span><br><span class="line">	<span class="keyword">if</span> (path.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">		path = path.substring(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//返回FileSystemResource类型的资源</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> FileSystemContextResource(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.ClassRelativeResourceLoader</p>
<p>ClassRelativeResourceLoader是另一个DefaultResourceLoader子类的实现，和FileSystemResourceLoader相似，都覆盖了getResourceByPath方法，并返回其对应的 ClassRelativeContextResource 的资源类型。ClassRelativeResourceLoader 扩展的功能是，可以根据给定的class 所在包或者所在包的子包下加载资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Resource <span class="title">getResourceByPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回ClassRelativeResource类型的资源</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ClassRelativeContextResource(path, <span class="keyword">this</span>.clazz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.ResourcePatternResolver</p>
<p>ResourceLoader 的 Resource getResource(String location) 方法，每次只能根据 location 返回一个 Resource 。当需要加载多个资源时，我们只能多次调用 #getResource(String location) 方法外。ResourcePatternResolver 是 ResourceLoader 的扩展，它可以根据指定的资源路径匹配模式每次返回多个 Resource 实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourcePatternResolver</span> <span class="keyword">extends</span> <span class="title">ResourceLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 类路径中所有匹配资源的伪URL前缀："classpath *："</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	String CLASSPATH_ALL_URL_PREFIX = <span class="string">"classpath*:"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 将给定的location解析为Resource对象(根据路径匹配为多个Resource对象)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	Resource[] getResources(String locationPattern) <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6.PathMatchingResourcePatternResolver</p>
<p>PathMatchingResourcePatternResolver是ResourcePatternResolver的实现类，它除了支持 ResourceLoader 和 ResourcePatternResolver 新增的 “classpath<em>:” 前缀外，还支持 Ant 风格的路径匹配模式（类似于 “**/</em>.xml”）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 资源加载器</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Ant路径匹配器</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> PathMatcher pathMatcher = <span class="keyword">new</span> AntPathMatcher();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 使用默认DefaultResourceLoader创建一个PathMatchingResourcePatternResolver</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">PathMatchingResourcePatternResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.resourceLoader = <span class="keyword">new</span> DefaultResourceLoader();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 使用传入其他ResourceLoader创建一个PathMatchingResourcePatternResolver</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">PathMatchingResourcePatternResolver</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">		Assert.notNull(resourceLoader, <span class="string">"ResourceLoader must not be null"</span>);</span><br><span class="line">		<span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 使用默认DefaultResourceLoader创建一个PathMatchingResourcePatternResolver，需指定classLoader</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.core.io.DefaultResourceLoader</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">PathMatchingResourcePatternResolver</span><span class="params">(@Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.resourceLoader = <span class="keyword">new</span> DefaultResourceLoader(classLoader);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 默认为Ant类型的路由匹配，也可以指定一个路由匹配规则</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.util.AntPathMatcher</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPathMatcher</span><span class="params">(PathMatcher pathMatcher)</span> </span>&#123;</span><br><span class="line">		Assert.notNull(pathMatcher, <span class="string">"PathMatcher must not be null"</span>);</span><br><span class="line">		<span class="keyword">this</span>.pathMatcher = pathMatcher;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>PathMatchingResourcePatternResolver在实例化时，如果不指定ResourceLoader,则会在内部构造一个DefaultResourceLoader,在 <strong>getResource()</strong> 时，如果我们在实例化的时候未指定 ResourceLoader 参数的情况下，那么在加载资源时，其实就是 DefaultResourceLoader 的过程。</p>
<p>返回多个资源的getResource()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Resource[] getResources(String locationPattern) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		Assert.notNull(locationPattern, <span class="string">"Location pattern must not be null"</span>);</span><br><span class="line">		<span class="comment">//location开头为："classpath *："</span></span><br><span class="line">		<span class="keyword">if</span> (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) &#123;</span><br><span class="line">			<span class="comment">//location截取classpath*：后是否表示可以匹配的模式</span></span><br><span class="line">			<span class="keyword">if</span> (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) &#123;</span><br><span class="line">				<span class="comment">//通过查找所有与给定位置模式匹配的资源</span></span><br><span class="line">				<span class="keyword">return</span> findPathMatchingResources(locationPattern);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 具有给定名称的所有类路径资源</span></span><br><span class="line">				<span class="comment">//通过ClassLoader查找具有给定位置的所有类位置资源。</span></span><br><span class="line">				<span class="keyword">return</span> findAllClassPathResources(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Generally only look for a pattern after a prefix here,</span></span><br><span class="line">			<span class="comment">// and on Tomcat only after the "*/" separator for its "war:" protocol.</span></span><br><span class="line">			<span class="comment">//截取“：”之后的路径</span></span><br><span class="line">			<span class="keyword">int</span> prefixEnd = (locationPattern.startsWith(<span class="string">"war:"</span>) ? locationPattern.indexOf(<span class="string">"*/"</span>) + <span class="number">1</span> :</span><br><span class="line">					locationPattern.indexOf(<span class="string">':'</span>) + <span class="number">1</span>);</span><br><span class="line">			<span class="comment">//路径是否表示可以匹配的模式（包含通配符）</span></span><br><span class="line">			<span class="keyword">if</span> (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) &#123;</span><br><span class="line">				<span class="comment">// a file pattern</span></span><br><span class="line">				<span class="comment">//通过查找所有与给定位置模式匹配的资源</span></span><br><span class="line">				<span class="keyword">return</span> findPathMatchingResources(locationPattern);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// a single resource with the given name</span></span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> Resource[] &#123;getResourceLoader().getResource(locationPattern)&#125;;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>location开头不是classpath:<em>，并且不包含通配符，则交给相应的resourceLoader来实现，<br>其他情况下，调用 *</em>findPathMatchingResources()** 和 <strong>findAllClassPathResources()</strong> 方法。</p>
<p>当location为’classpath:<em>‘开头，并且不包含通配符时，调用 *</em>findAllClassPathResources()** 方法</p>
<p>#findAllClassPathResources()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过ClassLoader查找具有给定location的所有类位置资源。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Resource[] findAllClassPathResources(String location) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	String path = location;</span><br><span class="line">	<span class="comment">//去除location中的第一个'/'</span></span><br><span class="line">	<span class="keyword">if</span> (path.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">		path = path.substring(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 真正执行加载所有 classpath 资源</span></span><br><span class="line">	Set&lt;Resource&gt; result = doFindAllClassPathResources(path);</span><br><span class="line">	<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">		logger.trace(<span class="string">"Resolved classpath location ["</span> + location + <span class="string">"] to resources "</span> + result);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 转换成 Resource 数组返回</span></span><br><span class="line">	<span class="keyword">return</span> result.toArray(<span class="keyword">new</span> Resource[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过ClassLoader查找具有给定路径的所有类位置资源。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Set&lt;Resource&gt; <span class="title">doFindAllClassPathResources</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	Set&lt;Resource&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">	<span class="comment">//获取当前使用的ClassLoader</span></span><br><span class="line">	ClassLoader cl = getClassLoader();</span><br><span class="line">	<span class="comment">//根据ClassLoader加载路径下的所有资源 &lt;1&gt;</span></span><br><span class="line">	Enumeration&lt;URL&gt; resourceUrls = (cl != <span class="keyword">null</span> ? cl.getResources(path) : ClassLoader.getSystemResources(path));</span><br><span class="line">	<span class="keyword">while</span> (resourceUrls.hasMoreElements()) &#123;</span><br><span class="line">		<span class="comment">//将URL转换成Resource对象</span></span><br><span class="line">		URL url = resourceUrls.nextElement();</span><br><span class="line">		result.add(convertClassLoaderURL(url));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="string">""</span>.equals(path)) &#123;</span><br><span class="line">		<span class="comment">//加载路径下的所有jar &lt;2&gt;</span></span><br><span class="line">		<span class="comment">// The above result is likely to be incomplete, i.e. only containing file system references.</span></span><br><span class="line">		<span class="comment">// We need to have pointers to each of the jar files on the classpath as well...</span></span><br><span class="line">		addAllClassLoaderJarRoots(cl, result);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&lt;1&gt;:根据classLoader加载路径下的所有资源，如果构造时未指定classLoader，就使用 <strong>ClassLoader.getSystemResources(path)</strong> 方法，指定则调用当前ClassLoader的 <strong>getResource()</strong> 方法</p>
<p>&lt;2&gt;:如果传入的path是””或者”/“就调用 <strong>addAllClassLoaderJarRoots</strong>方法加载路径下的所有jar</p>
<p>当location包含通配符时，调用 <strong>findPathMatchingResources()</strong> 方法</p>
<p>#findPathMatchingResources():</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过查找所有与location匹配的资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Resource[] findPathMatchingResources(String locationPattern) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	<span class="comment">//确定根路径</span></span><br><span class="line">	String rootDirPath = determineRootDir(locationPattern);</span><br><span class="line">	<span class="comment">//确定子路径</span></span><br><span class="line">	String subPattern = locationPattern.substring(rootDirPath.length());</span><br><span class="line">	<span class="comment">//获取所有根路径资源，例:rootDir为classpath*:/properties，则获取的资源是所有含/properties的资源</span></span><br><span class="line">	Resource[] rootDirResources = getResources(rootDirPath);</span><br><span class="line">	Set&lt;Resource&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">	<span class="comment">//遍历所有根路径资源</span></span><br><span class="line">	<span class="keyword">for</span> (Resource rootDirResource : rootDirResources) &#123;</span><br><span class="line">		<span class="comment">//解析指定的资源以进行路径匹配</span></span><br><span class="line">		rootDirResource = resolveRootDirResource(rootDirResource);</span><br><span class="line">		<span class="comment">//当前resource类型为URL</span></span><br><span class="line">		URL rootDirUrl = rootDirResource.getURL();</span><br><span class="line">		<span class="comment">//类型为bundle</span></span><br><span class="line">		<span class="keyword">if</span> (equinoxResolveMethod != <span class="keyword">null</span> &amp;&amp; rootDirUrl.getProtocol().startsWith(<span class="string">"bundle"</span>)) &#123;</span><br><span class="line">			URL resolvedUrl = (URL) ReflectionUtils.invokeMethod(equinoxResolveMethod, <span class="keyword">null</span>, rootDirUrl);</span><br><span class="line">			<span class="keyword">if</span> (resolvedUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">				rootDirUrl = resolvedUrl;</span><br><span class="line">			&#125;</span><br><span class="line">			rootDirResource = <span class="keyword">new</span> UrlResource(rootDirUrl);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//类型为vfs</span></span><br><span class="line">		<span class="keyword">if</span> (rootDirUrl.getProtocol().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) &#123;</span><br><span class="line">			result.addAll(VfsResourceMatchingDelegate.findMatchingResources(rootDirUrl, subPattern, getPathMatcher()));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//类型为jar</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ResourceUtils.isJarURL(rootDirUrl) || isJarResource(rootDirResource)) &#123;</span><br><span class="line">			result.addAll(doFindPathMatchingJarResources(rootDirResource, rootDirUrl, subPattern));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//类型为file</span></span><br><span class="line">			result.addAll(doFindPathMatchingFileResources(rootDirResource, subPattern));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">		logger.trace(<span class="string">"Resolved location pattern ["</span> + locationPattern + <span class="string">"] to resources "</span> + result);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result.toArray(<span class="keyword">new</span> Resource[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法查找所有与location匹配的资源，首先要确定目录，然后在获取该目录下得所有资源。<br>在所获得的所有资源后，进行迭代匹配获取我们想要的资源。</p>
<p>其中 <strong>determineRootDir()</strong> 用于确定根路径</p>
<p>#determineRootDir():</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取location的根目录。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">determineRootDir</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 找到：后一位位置  classpath*:/</span></span><br><span class="line">	<span class="keyword">int</span> prefixEnd = location.indexOf(<span class="string">':'</span>) + <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//  根目录的结束位置</span></span><br><span class="line">	<span class="keyword">int</span> rootDirEnd = location.length();</span><br><span class="line">	<span class="comment">// 从：开始到最后的字符串循环判断是否存在通配符，如果存在，就截取最后一个由'/'分割的部分</span></span><br><span class="line">	<span class="comment">// 例：location=classpath:/META-INF/service/*.xml,最后一个由'/'分割的部分是*.xml，再循环判断剩下的部分，</span></span><br><span class="line">	<span class="comment">// 直到剩下的部分都不包含通配符，这边剩下的部分没有通配符，所以根目录就是classpath:/META-INF/service/</span></span><br><span class="line">	<span class="keyword">while</span> (rootDirEnd &gt; prefixEnd &amp;&amp; getPathMatcher().isPattern(location.substring(prefixEnd, rootDirEnd))) &#123;</span><br><span class="line">		rootDirEnd = location.lastIndexOf(<span class="string">'/'</span>, rootDirEnd - <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果查找完成后，rootDirEnd成了0，就把之前的'：'后一位的位置给它</span></span><br><span class="line">	<span class="keyword">if</span> (rootDirEnd == <span class="number">0</span>) &#123;</span><br><span class="line">		rootDirEnd = prefixEnd;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//截取根目录</span></span><br><span class="line">	<span class="keyword">return</span> location.substring(<span class="number">0</span>, rootDirEnd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例：</p>
<table>
<thead>
<tr>
<th>原路径</th>
<th>根路径</th>
</tr>
</thead>
<tbody><tr>
<td>classpath:/META-INF/service/*.xml</td>
<td>classpath:/META-INF/service/</td>
</tr>
<tr>
<td>classpath:/META-INF/a<em>/</em></td>
<td>classpath:/META-INF/</td>
</tr>
</tbody></table>
<p>三种资源类型:vfs、jar、file</p>
<p>file:doFindPathMatchingFileResources():</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">protected Set&lt;Resource&gt; doFindPathMatchingFileResources(Resource rootDirResource, String subPattern)</span><br><span class="line">			throws IOException &#123;</span><br><span class="line"></span><br><span class="line">		File rootDir;</span><br><span class="line">		try &#123;</span><br><span class="line">			&#x2F;&#x2F;获取资源绝对路径</span><br><span class="line">			rootDir &#x3D; rootDirResource.getFile().getAbsoluteFile();</span><br><span class="line">		&#125;</span><br><span class="line">		catch (FileNotFoundException ex) &#123;</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(&quot;Cannot search for matching files underneath &quot; + rootDirResource +</span><br><span class="line">						&quot; in the file system: &quot; + ex.getMessage());</span><br><span class="line">			&#125;</span><br><span class="line">			return Collections.emptySet();</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Exception ex) &#123;</span><br><span class="line">			if (logger.isInfoEnabled()) &#123;</span><br><span class="line">				logger.info(&quot;Failed to resolve &quot; + rootDirResource + &quot; in the file system: &quot; + ex);</span><br><span class="line">			&#125;</span><br><span class="line">			return Collections.emptySet();</span><br><span class="line">		&#125;</span><br><span class="line">		return doFindMatchingFileSystemResources(rootDir, subPattern);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 查找文件系统中与location匹配的所有资源</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	protected Set&lt;Resource&gt; doFindMatchingFileSystemResources(File rootDir, String subPattern) throws IOException &#123;</span><br><span class="line">		if (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(&quot;Looking for matching resources in directory tree [&quot; + rootDir.getPath() + &quot;]&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		Set&lt;File&gt; matchingFiles &#x3D; retrieveMatchingFiles(rootDir, subPattern);</span><br><span class="line">		Set&lt;Resource&gt; result &#x3D; new LinkedHashSet&lt;&gt;(matchingFiles.size());</span><br><span class="line">		&#x2F;&#x2F;将File转为FileSystemResource</span><br><span class="line">		for (File file : matchingFiles) &#123;</span><br><span class="line">			result.add(new FileSystemResource(file));</span><br><span class="line">		&#125;</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 查找与给定路径模式匹配的文件，</span><br><span class="line">	 * 检查给定目录及其子目录。</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	protected Set&lt;File&gt; retrieveMatchingFiles(File rootDir, String pattern) throws IOException &#123;</span><br><span class="line">		&#x2F;&#x2F;根目录是否存在</span><br><span class="line">		if (!rootDir.exists()) &#123;</span><br><span class="line">			&#x2F;&#x2F; Silently skip non-existing directories.</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(&quot;Skipping [&quot; + rootDir.getAbsolutePath() + &quot;] because it does not exist&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			return Collections.emptySet();</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;根目录是否是目录</span><br><span class="line">		if (!rootDir.isDirectory()) &#123;</span><br><span class="line">			&#x2F;&#x2F; Complain louder if it exists but is no directory.</span><br><span class="line">			if (logger.isInfoEnabled()) &#123;</span><br><span class="line">				logger.info(&quot;Skipping [&quot; + rootDir.getAbsolutePath() + &quot;] because it does not denote a directory&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			return Collections.emptySet();</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;根目录是否可读</span><br><span class="line">		if (!rootDir.canRead()) &#123;</span><br><span class="line">			if (logger.isInfoEnabled()) &#123;</span><br><span class="line">				logger.info(&quot;Skipping search for matching files underneath directory [&quot; + rootDir.getAbsolutePath() +</span><br><span class="line">						&quot;] because the application is not allowed to read the directory&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			return Collections.emptySet();</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;将所有分隔符都替换为&#x2F;</span><br><span class="line">		String fullPattern &#x3D; StringUtils.replace(rootDir.getAbsolutePath(), File.separator, &quot;&#x2F;&quot;);</span><br><span class="line"></span><br><span class="line">		if (!pattern.startsWith(&quot;&#x2F;&quot;)) &#123;</span><br><span class="line">			fullPattern +&#x3D; &quot;&#x2F;&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		fullPattern &#x3D; fullPattern + StringUtils.replace(pattern, File.separator, &quot;&#x2F;&quot;);</span><br><span class="line">		Set&lt;File&gt; result &#x3D; new LinkedHashSet&lt;&gt;(8);</span><br><span class="line">		&#x2F;&#x2F;查找匹配文件</span><br><span class="line">		doRetrieveMatchingFiles(fullPattern, rootDir, result);</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 递归检索与给定模式匹配的文件，</span><br><span class="line">	 * 将它们添加到给定的结果列表中。</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	protected void doRetrieveMatchingFiles(String fullPattern, File dir, Set&lt;File&gt; result) throws IOException &#123;</span><br><span class="line">		if (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(&quot;Searching directory [&quot; + dir.getAbsolutePath() +</span><br><span class="line">					&quot;] for files matching pattern [&quot; + fullPattern + &quot;]&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;获取目录下所有文件</span><br><span class="line">		for (File content : listDirectory(dir)) &#123;</span><br><span class="line"></span><br><span class="line">			String currPath &#x3D; StringUtils.replace(content.getAbsolutePath(), File.separator, &quot;&#x2F;&quot;);</span><br><span class="line">			&#x2F;&#x2F;查找到的子文件仍是目录且以根目录为开头</span><br><span class="line">			if (content.isDirectory() &amp;&amp; getPathMatcher().matchStart(fullPattern, currPath + &quot;&#x2F;&quot;)) &#123;</span><br><span class="line">				if (!content.canRead()) &#123;</span><br><span class="line">					if (logger.isDebugEnabled()) &#123;</span><br><span class="line">						logger.debug(&quot;Skipping subdirectory [&quot; + dir.getAbsolutePath() +</span><br><span class="line">								&quot;] because the application is not allowed to read the directory&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					&#x2F;&#x2F;递归调用查找所有的文件</span><br><span class="line">					doRetrieveMatchingFiles(fullPattern, content, result);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F;查看当前文件按是否匹配，匹配则添加</span><br><span class="line">			if (getPathMatcher().match(fullPattern, currPath)) &#123;</span><br><span class="line">				result.add(content);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>file类型的资源获取，主要分为 </p>
<p>1.根据根目录资源获取资源绝对路径 </p>
<p>2.检查目录有效性 </p>
<p>3.查找目录下匹配文件</p>

            </div>
          

    
      <footer class="post-footer">
		

        
        
  <nav class="post-nav">
    
    
      <a class="next" href="/2020/05/28/spring%20Resource/">
        <span class="next-text nav-default">spring Resource</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2014 -
    
    2020
    <span class="footer-author">John Doe.</span>
    <span class="power-by">
        Powered by <a class="hexo-link" href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> and <a class="theme-link" href="https://github.com/frostfan/hexo-theme-polarbear" target="_blank" rel="noopener">Polar Bear</a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
